/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BidirectionalFolgezettelPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DuplicateAddressModal = class extends import_obsidian.Modal {
  constructor(app, address, existingFile, onConfirm, onCancel) {
    super(app);
    this.address = address;
    this.existingFile = existingFile;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u26A0\uFE0F Duplicate Folgezettel Address" });
    contentEl.createEl("p", {
      text: `The folgezettel address "${this.address}" is already used by:`
    });
    const fileInfo = contentEl.createEl("div", { cls: "duplicate-file-info" });
    fileInfo.style.padding = "10px";
    fileInfo.style.margin = "10px 0";
    fileInfo.style.backgroundColor = "var(--background-secondary)";
    fileInfo.style.borderRadius = "5px";
    fileInfo.style.fontFamily = "var(--font-monospace)";
    fileInfo.createEl("strong", { text: this.existingFile.path });
    contentEl.createEl("p", {
      text: "Creating another note with the same address may cause confusion in your Zettelkasten. Do you want to proceed anyway?"
    });
    const buttonContainer = contentEl.createEl("div", { cls: "modal-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
      this.onCancel();
    });
    const confirmButton = buttonContainer.createEl("button", {
      text: "Create Anyway",
      cls: "mod-warning"
    });
    confirmButton.style.backgroundColor = "var(--interactive-accent)";
    confirmButton.style.color = "var(--text-on-accent)";
    confirmButton.addEventListener("click", () => {
      this.close();
      this.onConfirm();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var DEFAULT_SETTINGS = {
  autoProcess: true,
  showNotifications: true,
  autoBidirectionalLinks: true,
  parentLinkDescription: "Parent",
  childLinkDescription: "Child",
  backlinkHeading: "Related Notes",
  forwardLinkHeading: "Child Notes",
  crossLinkHeading: "Related Notes"
};
var BidirectionalFolgezettelPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.fileContentCache = /* @__PURE__ */ new Map();
    this.processingFile = null;
    this.recentlyCreatedFiles = /* @__PURE__ */ new Set();
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "add-backlink-to-parent",
      name: "Add backlink to parent note",
      callback: () => this.addBacklinkToParent()
    });
    this.addCommand({
      id: "create-next-child",
      name: "Create next child note",
      callback: () => this.createNextChild()
    });
    this.addCommand({
      id: "suggest-next-child",
      name: "Suggest next child address",
      callback: () => this.suggestNextChildCommand()
    });
    this.addRibbonIcon("link", "Folgezettel: Add parent link", () => {
      this.addBacklinkToParent();
    });
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian.TFile) {
          this.recentlyCreatedFiles.add(file.path);
          this.checkForDuplicateAddress(file);
          if (this.settings.autoProcess) {
            this.processNewFile(file);
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian.TFile) {
          if (this.recentlyCreatedFiles.has(oldPath)) {
            this.recentlyCreatedFiles.delete(oldPath);
            this.recentlyCreatedFiles.add(file.path);
          }
          this.checkForDuplicateAddress(file);
          if (this.settings.autoProcess) {
            this.processNewFile(file);
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.settings.autoBidirectionalLinks && file instanceof import_obsidian.TFile) {
          this.onFileModify(file);
        }
      })
    );
    this.addSettingTab(new FolgezettelSettingTab(this.app, this));
  }
  /**
   * Check if a file's folgezettel address is already used by another file.
   * Shows a warning notice if duplicate is detected.
   * Uses a non-blocking Notice to avoid interrupting title editing.
   */
  checkForDuplicateAddress(file) {
    const address = this.extractFromTitle(file.basename);
    if (!address)
      return;
    const files = this.app.vault.getMarkdownFiles();
    for (const otherFile of files) {
      if (otherFile.path === file.path)
        continue;
      const otherAddress = this.extractFromTitle(otherFile.basename);
      if (otherAddress === address) {
        new import_obsidian.Notice(
          `\u26A0\uFE0F Duplicate folgezettel address!

"${address}" is already used by:
${otherFile.path}

Consider using a different address.`,
          15e3
          // Show for 15 seconds
        );
        return;
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ========================================================================
  // Address Parsing
  // ========================================================================
  /**
   * Parse a folgezettel address string into its component segments.
   * Valid formats: "1.2a3c5", "1.13aa", "1.2a15", etc.
   * The address must start with a number.
   */
  parseAddress(address) {
    if (!address || typeof address !== "string") {
      return null;
    }
    const trimmed = address.trim();
    if (!trimmed) {
      return null;
    }
    if (!/^\d/.test(trimmed)) {
      return null;
    }
    const segments = [];
    let current = "";
    let isNumber = true;
    for (const char of trimmed) {
      if (char === ".") {
        if (current) {
          segments.push(isNumber ? parseInt(current, 10) : current);
          current = "";
        }
        isNumber = true;
      } else if (/\d/.test(char)) {
        if (!isNumber && current) {
          segments.push(current);
          current = "";
        }
        isNumber = true;
        current += char;
      } else if (/[a-zA-Z]/.test(char)) {
        if (isNumber && current) {
          segments.push(parseInt(current, 10));
          current = "";
        }
        isNumber = false;
        current += char.toLowerCase();
      } else {
        break;
      }
    }
    if (current) {
      segments.push(isNumber ? parseInt(current, 10) : current);
    }
    if (segments.length === 0) {
      return null;
    }
    return {
      segments,
      raw: trimmed
    };
  }
  /**
   * Extract a folgezettel address from a note title.
   * The address should be at the beginning or clearly identifiable.
   */
  extractFromTitle(title) {
    if (!title)
      return null;
    const match = title.match(/^(\d+(?:\.\d+)*(?:[a-zA-Z]+\d*)*)/);
    if (match) {
      return match[1];
    }
    const anyMatch = title.match(/(\d+(?:\.\d+)*(?:[a-zA-Z]+\d*)*)/);
    if (anyMatch) {
      return anyMatch[1];
    }
    return null;
  }
  /**
   * Compute the parent address from a given folgezettel address.
   * For "1.2a3", parent is "1.2a". For "1.2a", parent is "1.2".
   */
  getParentAddress(address) {
    const parsed = this.parseAddress(address);
    if (!parsed || parsed.segments.length <= 1) {
      return null;
    }
    const parentSegments = parsed.segments.slice(0, -1);
    return this.segmentsToAddress(parentSegments);
  }
  /**
   * Convert segments array back to address string.
   */
  segmentsToAddress(segments) {
    let result = "";
    let lastWasNumber = false;
    for (let i = 0; i < segments.length; i++) {
      const seg = segments[i];
      const isNum = typeof seg === "number";
      if (i === 0) {
        result = String(seg);
      } else if (isNum && lastWasNumber) {
        result += "." + seg;
      } else {
        result += seg;
      }
      lastWasNumber = isNum;
    }
    return result;
  }
  // ========================================================================
  // File Operations
  // ========================================================================
  /**
   * Find a file in the vault by its folgezettel address.
   */
  findParentFile(parentAddress) {
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const titleAddress = this.extractFromTitle(file.basename);
      if (titleAddress === parentAddress) {
        return file;
      }
    }
    return null;
  }
  /**
   * Find a file in the vault by its exact folgezettel address.
   * Returns the file if found, null otherwise.
   */
  findFileByAddress(address) {
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const titleAddress = this.extractFromTitle(file.basename);
      if (titleAddress === address) {
        return file;
      }
    }
    return null;
  }
  /**
   * Validate a proposed folgezettel address.
   * Checks if the address is valid and not already in use.
   */
  validateAddress(address) {
    const parsed = this.parseAddress(address);
    if (!parsed) {
      return {
        isValid: false,
        isDuplicate: false,
        existingFile: null,
        message: `Invalid folgezettel address: "${address}"`
      };
    }
    const existingFile = this.findFileByAddress(address);
    if (existingFile) {
      return {
        isValid: true,
        isDuplicate: true,
        existingFile,
        message: `Address "${address}" is already used by: ${existingFile.path}`
      };
    }
    return {
      isValid: true,
      isDuplicate: false,
      existingFile: null,
      message: `Address "${address}" is available`
    };
  }
  /**
   * Find a file by its basename (without extension).
   */
  findFileByBasename(basename) {
    const files = this.app.vault.getMarkdownFiles();
    const normalizedBasename = basename.toLowerCase();
    for (const file of files) {
      if (file.basename.toLowerCase() === normalizedBasename) {
        return file;
      }
    }
    return null;
  }
  /**
   * Extract all wiki-style links from content.
   */
  extractLinks(content) {
    const links = /* @__PURE__ */ new Set();
    const linkRegex = /\[\[([^\]|#]+)(?:[|#][^\]]+)?\]\]/g;
    let match;
    while ((match = linkRegex.exec(content)) !== null) {
      links.add(match[1].trim());
    }
    return links;
  }
  /**
   * Insert a link under a specific heading, at the end of the section.
   * If description is empty, the link is inserted without parentheses.
   */
  async insertLinkUnderHeading(file, linkedFile, heading, description) {
    const content = await this.app.vault.read(file);
    const linkText = description.trim() ? `- [[${linkedFile.basename}]] (${description})` : `- [[${linkedFile.basename}]]`;
    if (content.includes(`[[${linkedFile.basename}]]`)) {
      return false;
    }
    const headingRegex = new RegExp(`^## ${heading}\\s*$`, "m");
    const headingMatch = content.match(headingRegex);
    let newContent;
    if (headingMatch && headingMatch.index !== void 0) {
      const afterHeading = content.slice(headingMatch.index + headingMatch[0].length);
      const nextHeadingMatch = afterHeading.match(/\n## /);
      let insertPosition;
      if (nextHeadingMatch && nextHeadingMatch.index !== void 0) {
        insertPosition = headingMatch.index + headingMatch[0].length + nextHeadingMatch.index;
      } else {
        insertPosition = content.length;
      }
      const beforeInsert = content.slice(0, insertPosition);
      const trimmedBefore = beforeInsert.trimEnd();
      newContent = trimmedBefore + "\n" + linkText + "\n" + content.slice(insertPosition);
    } else {
      newContent = content.trimEnd() + "\n\n## " + heading + "\n" + linkText + "\n";
    }
    await this.app.vault.modify(file, newContent);
    return true;
  }
  // ========================================================================
  // Core Functionality
  // ========================================================================
  /**
   * Process a newly created file to add folgezettel links.
   * Duplicate address detection is handled separately by checkForDuplicateAddress().
   */
  async processNewFile(file) {
    const address = this.extractFromTitle(file.basename);
    if (!address)
      return;
    const parentAddress = this.getParentAddress(address);
    if (!parentAddress)
      return;
    const parentFile = this.findParentFile(parentAddress);
    if (!parentFile) {
      if (this.settings.showNotifications) {
        new import_obsidian.Notice(`Parent note not found for address: ${parentAddress}`);
      }
      return;
    }
    const backlinkInserted = await this.insertLinkUnderHeading(
      file,
      parentFile,
      this.settings.backlinkHeading,
      this.settings.parentLinkDescription
    );
    const forwardLinkInserted = await this.insertLinkUnderHeading(
      parentFile,
      file,
      this.settings.forwardLinkHeading,
      this.settings.childLinkDescription
    );
    if (this.settings.showNotifications) {
      if (backlinkInserted || forwardLinkInserted) {
        new import_obsidian.Notice(`Folgezettel links created for ${file.basename}`);
      }
    }
  }
  /**
   * Command: Add backlink to parent note for the current file.
   */
  async addBacklinkToParent() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian.Notice("No active note");
      return;
    }
    const file = activeView.file;
    const address = this.extractFromTitle(file.basename);
    if (!address) {
      new import_obsidian.Notice("No folgezettel address found in note title");
      return;
    }
    const parentAddress = this.getParentAddress(address);
    if (!parentAddress) {
      new import_obsidian.Notice("This appears to be a root note (no parent)");
      return;
    }
    const parentFile = this.findParentFile(parentAddress);
    if (!parentFile) {
      new import_obsidian.Notice(`Parent note not found for address: ${parentAddress}`);
      return;
    }
    const backlinkInserted = await this.insertLinkUnderHeading(
      file,
      parentFile,
      this.settings.backlinkHeading,
      this.settings.parentLinkDescription
    );
    const forwardLinkInserted = await this.insertLinkUnderHeading(
      parentFile,
      file,
      this.settings.forwardLinkHeading,
      this.settings.childLinkDescription
    );
    if (backlinkInserted || forwardLinkInserted) {
      new import_obsidian.Notice(`Links created: ${file.basename} \u2194 ${parentFile.basename}`);
    } else {
      new import_obsidian.Notice("Links already exist");
    }
  }
  // ========================================================================
  // Child Note Suggestions
  // ========================================================================
  /**
   * Get the next letter in sequence (a -> b, z -> aa, az -> ba).
   */
  nextLetterSequence(letters) {
    if (!letters)
      return "a";
    const chars = letters.split("");
    let i = chars.length - 1;
    while (i >= 0) {
      if (chars[i] === "z") {
        chars[i] = "a";
        i--;
      } else {
        chars[i] = String.fromCharCode(chars[i].charCodeAt(0) + 1);
        return chars.join("");
      }
    }
    return "a" + chars.join("");
  }
  /**
   * Determine if a parent address ends with a letter or number.
   * Returns 'letter' if ends with letter, 'number' if ends with number.
   */
  getLastSegmentType(address) {
    const parsed = this.parseAddress(address);
    if (!parsed || parsed.segments.length === 0) {
      return null;
    }
    const lastSegment = parsed.segments[parsed.segments.length - 1];
    return typeof lastSegment === "string" ? "letter" : "number";
  }
  /**
   * Get existing children of a note by address.
   */
  getChildrenOf(address) {
    const files = this.app.vault.getMarkdownFiles();
    const children = [];
    for (const file of files) {
      const fileAddress = this.extractFromTitle(file.basename);
      if (!fileAddress)
        continue;
      const parentOfFile = this.getParentAddress(fileAddress);
      if (parentOfFile === address) {
        children.push(fileAddress);
      }
    }
    return children;
  }
  /**
   * Check if an address is a root node (single number like "7" or "7.").
   * Root nodes are special because their children use dot-number format (7.1, 7.2)
   * rather than letter format (7a, 7b).
   */
  isRootNode(address) {
    const parsed = this.parseAddress(address);
    if (!parsed)
      return false;
    return parsed.segments.length === 1 && typeof parsed.segments[0] === "number";
  }
  /**
   * Suggest the next child address for a given parent address.
   * Follows folgezettel alternation rules:
   * - If parent is a root node (e.g., "7"), child uses dot-number (7.1, 7.2)
   * - If parent ends with number after dot (e.g., "1.2"), child ends with letter (1.2a)
   * - If parent ends with letter (e.g., "1.2a"), child ends with number (1.2a1)
   */
  suggestNextChild(parentAddress) {
    const children = this.getChildrenOf(parentAddress);
    const lastSegmentType = this.getLastSegmentType(parentAddress);
    if (this.isRootNode(parentAddress)) {
      if (children.length === 0) {
        return parentAddress + ".1";
      }
      let maxNumber = 0;
      for (const child of children) {
        const parsed = this.parseAddress(child);
        if (!parsed || parsed.segments.length < 2)
          continue;
        const lastSegment = parsed.segments[parsed.segments.length - 1];
        if (typeof lastSegment === "number") {
          if (lastSegment > maxNumber) {
            maxNumber = lastSegment;
          }
        }
      }
      return parentAddress + "." + (maxNumber + 1);
    }
    if (lastSegmentType === "letter") {
      if (children.length === 0) {
        return parentAddress + "1";
      }
      let maxNumber = 0;
      for (const child of children) {
        const parsed = this.parseAddress(child);
        if (!parsed)
          continue;
        const lastSegment = parsed.segments[parsed.segments.length - 1];
        if (typeof lastSegment === "number") {
          if (lastSegment > maxNumber) {
            maxNumber = lastSegment;
          }
        }
      }
      return parentAddress + (maxNumber + 1);
    } else {
      if (children.length === 0) {
        return parentAddress + "a";
      }
      let maxLetters = "";
      for (const child of children) {
        const parsed = this.parseAddress(child);
        if (!parsed)
          continue;
        const lastSegment = parsed.segments[parsed.segments.length - 1];
        if (typeof lastSegment === "string") {
          if (lastSegment > maxLetters) {
            maxLetters = lastSegment;
          }
        }
      }
      const nextLetters = this.nextLetterSequence(maxLetters);
      return parentAddress + nextLetters;
    }
  }
  /**
   * Command: Suggest next child address.
   */
  suggestNextChildCommand() {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian.Notice("No active note");
      return;
    }
    const address = this.extractFromTitle(activeView.file.basename);
    if (!address) {
      new import_obsidian.Notice("No folgezettel address found in note title");
      return;
    }
    const nextChild = this.suggestNextChild(address);
    const validation = this.validateAddress(nextChild);
    if (validation.isDuplicate) {
      new import_obsidian.Notice(`\u26A0\uFE0F Warning: ${nextChild} already exists in ${(_a = validation.existingFile) == null ? void 0 : _a.path}`);
    } else {
      new import_obsidian.Notice(`Next child address: ${nextChild}`);
    }
  }
  /**
   * Command: Create next child note.
   */
  async createNextChild() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView || !activeView.file) {
      new import_obsidian.Notice("No active note");
      return;
    }
    const parentAddress = this.extractFromTitle(activeView.file.basename);
    if (!parentAddress) {
      new import_obsidian.Notice("No folgezettel address found in note title");
      return;
    }
    const childAddress = this.suggestNextChild(parentAddress);
    const validation = this.validateAddress(childAddress);
    if (validation.isDuplicate && validation.existingFile) {
      new DuplicateAddressModal(
        this.app,
        childAddress,
        validation.existingFile,
        // On confirm: create the file anyway
        async () => {
          await this.createNoteWithAddress(childAddress, activeView.file.parent);
        },
        // On cancel: do nothing
        () => {
          new import_obsidian.Notice("Note creation cancelled");
        }
      ).open();
    } else {
      await this.createNoteWithAddress(childAddress, activeView.file.parent);
    }
  }
  /**
   * Create a new note with the given folgezettel address.
   */
  async createNoteWithAddress(address, parentFolder) {
    const fileName = `${address}.md`;
    const filePath = parentFolder ? `${parentFolder.path}/${fileName}` : fileName;
    try {
      const newFile = await this.app.vault.create(filePath, "");
      await this.app.workspace.getLeaf().openFile(newFile);
      new import_obsidian.Notice(`Created note: ${address}`);
    } catch (error) {
      new import_obsidian.Notice(`Failed to create note: ${error}`);
    }
  }
  // ========================================================================
  // Bidirectional Cross-Linking
  // ========================================================================
  /**
   * Handle file modification events for bidirectional linking.
   */
  async onFileModify(file) {
    if (!(file instanceof import_obsidian.TFile))
      return;
    if (file.extension !== "md")
      return;
    if (this.processingFile === file.path)
      return;
    const content = await this.app.vault.read(file);
    const currentLinks = this.extractLinks(content);
    const previousLinks = this.fileContentCache.get(file.path) || /* @__PURE__ */ new Set();
    const newLinks = /* @__PURE__ */ new Set();
    for (const link of currentLinks) {
      if (!previousLinks.has(link)) {
        newLinks.add(link);
      }
    }
    this.fileContentCache.set(file.path, currentLinks);
    if (newLinks.size > 0) {
      await this.processNewLinks(file, newLinks);
    }
  }
  /**
   * Process new links and create reciprocal links.
   */
  async processNewLinks(sourceFile, newLinks) {
    for (const linkTarget of newLinks) {
      const targetFile = this.findFileByBasename(linkTarget);
      if (!targetFile)
        continue;
      if (targetFile.path === sourceFile.path)
        continue;
      const targetContent = await this.app.vault.read(targetFile);
      if (targetContent.includes(`[[${sourceFile.basename}]]`)) {
        continue;
      }
      await this.insertCrossLink(targetFile, sourceFile);
    }
  }
  /**
   * Insert a cross-reference link in a file.
   */
  async insertCrossLink(file, linkedFile) {
    this.processingFile = file.path;
    try {
      const inserted = await this.insertLinkUnderHeading(
        file,
        linkedFile,
        this.settings.crossLinkHeading,
        "Cross-reference"
      );
      if (inserted && this.settings.showNotifications) {
        new import_obsidian.Notice(`Reciprocal link added: ${linkedFile.basename} \u2192 ${file.basename}`);
      }
    } finally {
      this.processingFile = null;
    }
  }
};
var FolgezettelSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Bidirectional Folgezettel Settings" });
    new import_obsidian.Setting(containerEl).setName("Auto-process new notes").setDesc("Automatically add folgezettel links when new notes are created").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoProcess).onChange(async (value) => {
      this.plugin.settings.autoProcess = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show notifications").setDesc("Display notifications when links are inserted").addToggle((toggle) => toggle.setValue(this.plugin.settings.showNotifications).onChange(async (value) => {
      this.plugin.settings.showNotifications = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto bidirectional cross-links").setDesc("Automatically create reciprocal links when you link to another note").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoBidirectionalLinks).onChange(async (value) => {
      this.plugin.settings.autoBidirectionalLinks = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Link Descriptions" });
    new import_obsidian.Setting(containerEl).setName("Parent link description").setDesc("Text shown after parent backlinks").addText((text) => text.setValue(this.plugin.settings.parentLinkDescription).onChange(async (value) => {
      this.plugin.settings.parentLinkDescription = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Child link description").setDesc("Text shown after child forward links").addText((text) => text.setValue(this.plugin.settings.childLinkDescription).onChange(async (value) => {
      this.plugin.settings.childLinkDescription = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Headings" });
    new import_obsidian.Setting(containerEl).setName("Backlink heading").setDesc("Heading for parent backlinks section").addText((text) => text.setValue(this.plugin.settings.backlinkHeading).onChange(async (value) => {
      this.plugin.settings.backlinkHeading = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Forward link heading").setDesc("Heading for child forward links section").addText((text) => text.setValue(this.plugin.settings.forwardLinkHeading).onChange(async (value) => {
      this.plugin.settings.forwardLinkHeading = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Cross-link heading").setDesc("Heading for cross-reference links section").addText((text) => text.setValue(this.plugin.settings.crossLinkHeading).onChange(async (value) => {
      this.plugin.settings.crossLinkHeading = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Folgezettel Address Format" });
    const helpDiv = containerEl.createDiv({ cls: "folgezettel-help" });
    helpDiv.createEl("p", {
      text: "Valid folgezettel addresses start with a number and can include dot-separated numbers and letter sequences:"
    });
    const table = helpDiv.createEl("table");
    const examples = [
      ["1", "Root note"],
      ["1.2", "Second-level note"],
      ["1.2a", "First child of 1.2"],
      ["1.2a3", "Third sub-branch of 1.2a"],
      ["1.2a3c5", "Deep nesting"]
    ];
    for (const [addr, desc] of examples) {
      const row = table.createEl("tr");
      row.createEl("td", { text: addr });
      row.createEl("td", { text: desc });
    }
  }
};
